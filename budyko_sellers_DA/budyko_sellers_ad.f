C                           DISCLAIMER
C 
C   This file was generated by TAF version 6.8.2
C 
C   FASTOPT DISCLAIMS  ALL  WARRANTIES,  EXPRESS  OR  IMPLIED,
C   INCLUDING (WITHOUT LIMITATION) ALL IMPLIED  WARRANTIES  OF
C   MERCHANTABILITY  OR FITNESS FOR A PARTICULAR PURPOSE, WITH
C   RESPECT TO THE SOFTWARE AND USER PROGRAMS.   IN  NO  EVENT
C   SHALL  FASTOPT BE LIABLE FOR ANY LOST OR ANTICIPATED PROF-
C   ITS, OR ANY INDIRECT, INCIDENTAL, EXEMPLARY,  SPECIAL,  OR
C   CONSEQUENTIAL  DAMAGES, WHETHER OR NOT FASTOPT WAS ADVISED
C   OF THE POSSIBILITY OF SUCH DAMAGES.
C 
C                           Haftungsbeschraenkung
C   FastOpt gibt ausdruecklich keine Gewaehr, explizit oder indirekt,
C   bezueglich der Brauchbarkeit  der Software  fuer einen bestimmten
C   Zweck.   Unter  keinen  Umstaenden   ist  FastOpt   haftbar  fuer
C   irgendeinen Verlust oder nicht eintretenden erwarteten Gewinn und
C   allen indirekten,  zufaelligen,  exemplarischen  oder  speziellen
C   Schaeden  oder  Folgeschaeden  unabhaengig  von einer eventuellen
C   Mitteilung darueber an FastOpt.
C 

      subroutine budyko_sellers_ad( xxs, xxs_ad, j, j_ad )
C******************************************************************
C******************************************************************
C** This routine was generated by Automatic differentiation.     **
C** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.2   **
C******************************************************************
C******************************************************************
      implicit none

C==============================================
C declare parameters
C==============================================
      integer max_iter
      parameter ( max_iter = 100000 )
      integer n
      parameter ( n = 100 )

C==============================================
C declare arguments
C==============================================
      double precision j
      double precision j_ad
      double precision xxs
      double precision xxs_ad

C==============================================
C declare local variables
C==============================================
      double precision a1
      double precision a2
      double precision alpha(n)
      double precision alpha_ad(n)
      double precision diff
      double precision diff_ad
      double precision dt
      double precision dt_ad
      double precision dtdx_m
      double precision dtdx_m_ad
      double precision dtdx_p
      double precision dtdx_p_ad
      double precision dx
      double precision epsilon
      double precision fdiff(n)
      double precision fdiff_ad(n)
      double precision fin(n)
      double precision fin_ad(n)
      double precision fout(n)
      double precision fout_ad(n)
      integer i
      integer ice_i
      integer ip1
      integer iter
      double precision q
      double precision s0
      double precision sigma
      double precision sx(n)
      double precision t(n)
      double precision t1
      double precision t2
      double precision t_ad(n)
      double precision target_dt
      double precision tnew(n)
      double precision tnew_ad(n)
      double precision x(n)
      double precision xedges(n+1)
      double precision xm
      double precision xp

C----------------------------------------------
C RESET LOCAL ADJOINT VARIABLES NO ALLOC
C----------------------------------------------
      do ip1 = 1, n
        alpha_ad(ip1) = 0.d0
      end do
      diff_ad = 0.d0
      dt_ad = 0.d0
      dtdx_m_ad = 0.d0
      dtdx_p_ad = 0.d0
      do ip1 = 1, n
        fdiff_ad(ip1) = 0.d0
      end do
      do ip1 = 1, n
        fin_ad(ip1) = 0.d0
      end do
      do ip1 = 1, n
        fout_ad(ip1) = 0.d0
      end do
      do ip1 = 1, n
        t_ad(ip1) = 0.d0
      end do
      do ip1 = 1, n
        tnew_ad(ip1) = 0.d0
      end do

C----------------------------------------------
C OPEN TAPE tapex
C----------------------------------------------
      open(unit=60,file='TAF_tape_1_budyko_sellers_t',ACCESS='DIRECT',
     $RECL=n*8)

C----------------------------------------------
C FUNCTION AND TAPE COMPUTATIONS
C----------------------------------------------
      open(unit=99,file='target_E2P_deltaT.dat')
      read(unit=99,fmt=*) target_dt
      s0 = 1366.d0
      q = s0/4.d0
      sigma = 5.67d-8
      epsilon = 0.63d0
      diff = 0.6d0+xxs
      do i = 1, n+1
        xedges(i) = (-1.d0)+2.d0*(i-1)/float(n)
      end do
      do i = 1, n
        x(i) = 0.5d0*(xedges(i)+xedges(i+1))
      end do
      dx = x(2)-x(1)
      do i = 1, n
        sx(i) = q*(1.d0-0.482d0*x(i)**2)*1.35d0-55.d0
      end do
      do i = 1, n
        t(i) = 288.d0+60.d0*(1.d0-x(i)**2)-20.d0
      end do
      dt = dx**2/(2.d0*diff)*0.5d0
      t1 = 223.15d0
      t2 = 293.15d0
      a1 = 0.9d0
      a2 = 0.2d0
      do iter = 1, max_iter
        write(unit=60,rec=iter) t
        do i = 1, n
          if (t(i) .le. t1) then
            alpha(i) = a1
          else if (t(i) .ge. t2) then
            alpha(i) = a2
          else
            alpha(i) = a1+(a2-a1)*(t(i)-t1)/(t2-t1)
          endif
        end do
        do i = 1, n
          fin(i) = sx(i)*(1.d0-alpha(i))
          fout(i) = epsilon*sigma*t(i)**4
        end do
        do i = 1, n
          if (i .eq. 1) then
            dtdx_m = 0.d0
          else
            dtdx_m = (t(i)-t(i-1))/dx
          endif
          if (i .eq. n) then
            dtdx_p = 0.d0
          else
            dtdx_p = (t(i+1)-t(i))/dx
          endif
          xm = xedges(i)
          xp = xedges(i+1)
          fdiff(i) = diff*((1.d0-xp**2)*dtdx_p-(1.d0-xm**2)*dtdx_m)/dx
        end do
        do i = 1, n
          tnew(i) = t(i)+dt*(fin(i)-fout(i)+fdiff(i))
        end do
        do i = 1, n
          t(i) = tnew(i)
        end do
      end do
      j = 0.5*(0.5*(t(50)+t(51))-0.5*(t(1)+t(n))-target_dt)**2

C----------------------------------------------
C ADJOINT COMPUTATIONS
C----------------------------------------------
      t_ad(n) = t_ad(n)-0.5*j_ad*(0.5*(t(50)+t(51))-0.5*(t(1)+t(n))-
     $target_dt)
      t_ad(51) = t_ad(51)+0.5*j_ad*(0.5*(t(50)+t(51))-0.5*(t(1)+t(n))-
     $target_dt)
      t_ad(50) = t_ad(50)+0.5*j_ad*(0.5*(t(50)+t(51))-0.5*(t(1)+t(n))-
     $target_dt)
      t_ad(1) = t_ad(1)-0.5*j_ad*(0.5*(t(50)+t(51))-0.5*(t(1)+t(n))-
     $target_dt)
      j_ad = 0.d0
      do iter = max_iter, 1, -1
C$taf INCOMPLETE alpha,fdiff,fin,fout
        read(unit=60,rec=iter) t
        do i = 1, n
          if (t(i) .le. t1) then
            alpha(i) = a1
          else if (t(i) .ge. t2) then
            alpha(i) = a2
          else
            alpha(i) = a1+(a2-a1)*(t(i)-t1)/(t2-t1)
          endif
        end do
        do i = 1, n
          fin(i) = sx(i)*(1.d0-alpha(i))
          fout(i) = epsilon*sigma*t(i)**4
        end do
        do i = 1, n
          if (i .eq. 1) then
            dtdx_m = 0.d0
          else
            dtdx_m = (t(i)-t(i-1))/dx
          endif
          if (i .eq. n) then
            dtdx_p = 0.d0
          else
            dtdx_p = (t(i+1)-t(i))/dx
          endif
          xm = xedges(i)
          xp = xedges(i+1)
          fdiff(i) = diff*((1.d0-xp**2)*dtdx_p-(1.d0-xm**2)*dtdx_m)/dx
        end do
        do i = 1, n
          tnew_ad(i) = tnew_ad(i)+t_ad(i)
          t_ad(i) = 0.d0
        end do
        do i = 1, n
          dt_ad = dt_ad+tnew_ad(i)*(fin(i)-fout(i)+fdiff(i))
          fdiff_ad(i) = fdiff_ad(i)+tnew_ad(i)*dt
          fin_ad(i) = fin_ad(i)+tnew_ad(i)*dt
          fout_ad(i) = fout_ad(i)-tnew_ad(i)*dt
          t_ad(i) = t_ad(i)+tnew_ad(i)
          tnew_ad(i) = 0.d0
        end do
        do i = n, 1, -1
          if (i .eq. 1) then
            dtdx_m = 0.d0
          else
            dtdx_m = (t(i)-t(i-1))/dx
          endif
          if (i .eq. n) then
            dtdx_p = 0.d0
          else
            dtdx_p = (t(i+1)-t(i))/dx
          endif
          xm = xedges(i)
          xp = xedges(i+1)
          diff_ad = diff_ad+fdiff_ad(i)*(((1.d0-xp**2)*dtdx_p-(1.d0-xm**
     $2)*dtdx_m)/dx)
          dtdx_m_ad = dtdx_m_ad-fdiff_ad(i)*(diff*(1.d0-xm**2)/dx)
          dtdx_p_ad = dtdx_p_ad+fdiff_ad(i)*(diff*(1-xp**2)/dx)
          fdiff_ad(i) = 0.d0
          if (i .eq. n) then
            dtdx_p_ad = 0.d0
          else
            t_ad(i+1) = t_ad(i+1)+dtdx_p_ad/dx
            t_ad(i) = t_ad(i)-dtdx_p_ad/dx
            dtdx_p_ad = 0.d0
          endif
          if (i .eq. 1) then
            dtdx_m_ad = 0.d0
          else
            t_ad(i-1) = t_ad(i-1)-dtdx_m_ad/dx
            t_ad(i) = t_ad(i)+dtdx_m_ad/dx
            dtdx_m_ad = 0.d0
          endif
        end do
        do i = 1, n
          t_ad(i) = t_ad(i)+4*fout_ad(i)*(epsilon*sigma)*t(i)**3
          fout_ad(i) = 0.d0
          alpha_ad(i) = alpha_ad(i)-fin_ad(i)*sx(i)
          fin_ad(i) = 0.d0
        end do
        do i = 1, n
          if (t(i) .le. t1) then
            alpha_ad(i) = 0.d0
          else if (t(i) .ge. t2) then
            alpha_ad(i) = 0.d0
          else
            t_ad(i) = t_ad(i)+alpha_ad(i)*((a2-a1)/(t2-t1))
            alpha_ad(i) = 0.d0
          endif
        end do
      end do
      diff_ad = diff_ad-0.5d0*dt_ad*(2*dx**2/(2.d0*diff)/(2.d0*diff))
      dt_ad = 0.d0
      xxs_ad = xxs_ad+diff_ad
      diff_ad = 0.d0
      close(unit=99)

C----------------------------------------------
C CLOSE TAPE tapex
C----------------------------------------------
      close(unit=60)

      end

      subroutine budyko_sellers( xxs, j )
C******************************************************************
C******************************************************************
C** This routine was generated by Automatic differentiation.     **
C** FastOpt: Transformation of Algorithm in Fortran, TAF 6.8.2   **
C******************************************************************
C******************************************************************
      implicit none

C==============================================
C declare parameters
C==============================================
      integer max_iter
      parameter ( max_iter = 100000 )
      integer n
      parameter ( n = 100 )

C==============================================
C declare arguments
C==============================================
      double precision j
      double precision xxs

C==============================================
C declare local variables
C==============================================
      double precision a1
      double precision a2
      double precision alpha(n)
      double precision diff
      double precision dt
      double precision dtdx_m
      double precision dtdx_p
      double precision dx
      double precision epsilon
      double precision fdiff(n)
      double precision fin(n)
      double precision fout(n)
      integer i, ice_i
      integer iter
      double precision lat(n)
      double precision q
      double precision s0
      double precision sigma
      double precision sx(n)
      double precision t(n)
      double precision t1
      double precision t2
      double precision target_dt
      double precision tnew(n)
      double precision tol
      double precision x(n)
      double precision xedges(n+1)
      double precision xm
      double precision xp

      open(unit=99,file='target_E2P_deltaT.dat')
      read(unit=99,fmt=*) target_dt
      close(unit=99)
      s0 = 1366.d0
      q = s0/4.d0
      sigma = 5.67d-8
      epsilon = 0.63d0
      diff = 0.6d0+xxs
      tol = 1.d-9
      do i = 1, n+1
        xedges(i) = (-1.d0)+2.d0*(i-1)/float(n)
      end do
      do i = 1, n
        x(i) = 0.5d0*(xedges(i)+xedges(i+1))
      end do
      dx = x(2)-x(1)
      do i = 1, n
        lat(i) = asin(x(i))*180.d0/3.14159265d0
      end do
      do i = 1, n
        sx(i) = q*(1.d0-0.482d0*x(i)**2)*1.35d0-55.d0
      end do
      do i = 1, n
        t(i) = 288.d0+60.d0*(1.d0-x(i)**2)-20.d0
      end do
      dt = dx**2/(2.d0*diff)*0.5d0
      t1 = 223.15d0
      t2 = 293.15d0
      a1 = 0.9d0
      a2 = 0.2d0
      do iter = 1, max_iter
        do i = 1, n
          if (t(i) .le. t1) then
            alpha(i) = a1
          else if (t(i) .ge. t2) then
            alpha(i) = a2
          else
            alpha(i) = a1+(a2-a1)*(t(i)-t1)/(t2-t1)
          endif
        end do
        do i = 1, n
          fin(i) = sx(i)*(1.d0-alpha(i))
          fout(i) = epsilon*sigma*t(i)**4
        end do
        do i = 1, n
          if (i .eq. 1) then
            dtdx_m = 0.d0
          else
            dtdx_m = (t(i)-t(i-1))/dx
          endif
          if (i .eq. n) then
            dtdx_p = 0.d0
          else
            dtdx_p = (t(i+1)-t(i))/dx
          endif
          xm = xedges(i)
          xp = xedges(i+1)
          fdiff(i) = diff*((1.d0-xp**2)*dtdx_p-(1.d0-xm**2)*dtdx_m)/dx
        end do
        do i = 1, n
          tnew(i) = t(i)+dt*(fin(i)-fout(i)+fdiff(i))
        end do
        do i = 1, n
          t(i) = tnew(i)
        end do
      end do
      j = 0.5*(0.5*(t(50)+t(51))-0.5*(t(1)+t(n))-target_dt)**2
      ice_i = 0 
      do i = 1,50
        if ( t(i) .LE. 273.15 ) then
           ice_i = i
        endif
      end do       
      print *, 'pole T ', t(1), ' eq T ', t(50), ' ice i ', ice_i
      
      end
